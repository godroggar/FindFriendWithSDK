/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */

const path = require('path')
const fs = require('fs')
const yargs = require('yargs')
const fsExtra = require('fs-extra')

const webpack = require('webpack')

const {colorconsole} = require('./packager/lib/utils')
const info = require('./packager/lib/info')
// 暂时暴露全局
global.colorconsole = colorconsole

// 开发者传递的参数
const options = Object.assign({}, yargs.argv)

// 支持文件扩展名
const FILE_EXT_LIST = info.name.extList
// 排除资源文件扩展名
const FILE_EXT_NORES = FILE_EXT_LIST.concat(['.js', '.jsx', '.coffee', '.ts', '.tsx', '.vue', '.css', '.less', '.sass', '.styl', '.html', '.json', '.md'])

// 项目目录
const pathProject = process.cwd()
// 源代码目录
const pathSrc = path.join(pathProject, 'src')
// 输出目标目录
const nameBuild = 'build'
// 构建目录
const pathBuild = path.join(pathProject, nameBuild)
// 最终发布目录
const pathDist = path.join(pathProject, 'dist')
// 打包配置文件
const nameManifest = 'manifest.json'
const pathManifest = path.join(pathSrc, nameManifest)

// 入口文件
const nameEntry = 'game.js'
const pathEntry = path.join(pathSrc, nameEntry)

// 工具目录
const pathDirname = __dirname

// 校验项目工程
!validateProject()

// 项目名（如果没有, 则默认为Bundle）
const appPackageName = getProjectName()

// 资源文件
const zipReses = {}

// 提取脚本文件，资源文件
extractSourceFiles('.', false)

// 配置环境
const nodeConf = parseEnv()

const webpackConf = {
  entry: {
    game: pathEntry
  },
  output: {
    path: pathBuild,
    filename: '[name].js'
  },
  module: {
    rules: []
  },
  plugins: [
    // 定义环境变量
    new webpack.DefinePlugin({
      // 平台：na
      ENV_PLATFORM: JSON.stringify(nodeConf.NODE_PLATFORM),
      // 阶段: dv|qa|ol
      ENV_PHASE: JSON.stringify(nodeConf.NODE_PHASE),
      ENV_PHASE_DV: nodeConf.NODE_PHASE === 'dv',
      ENV_PHASE_QA: nodeConf.NODE_PHASE === 'qa',
      ENV_PHASE_OL: nodeConf.NODE_PHASE === 'ol'
    }),
    // 编译耗时
    function () {
      this.plugin('run', function (compiler, callback) {
        process.webpackDateS = new Date()
        callback()
      })
      this.plugin('watch-run', function (compiler, callback) {
        process.webpackDateS = new Date()
        callback()
      })
      this.plugin('done', function () {
        process.webpackDateE = new Date()
        const secCost = (process.webpackDateE - process.webpackDateS) / 1000
        colorconsole.info(`Build Time Cost: ${secCost}s`)
      })
    }
  ],
  node: {
    global: false
  },
  resolve: {
    modules: [
      'node_modules',
      // 测试用例在test目录下
      path.join(pathProject, 'test')
    ],
    extensions: ['.webpack.js', '.web.js', '.js', '.json'].concat(FILE_EXT_LIST)
  },
  stats: {
    children: false,
    chunks: false,
    chunkModules: false,
    chunkOrigins: false,
    modules: false,
    version: false,
    assets: false
  }
}

// 环境配置
if (nodeConf.NODE_PHASE === 'dv') {
  // 开发：sourcemap
  webpackConf.devtool = 'source-map'
}
else {
  // 正式：压缩去重
  webpackConf.plugins.push(new webpack.optimize.DedupePlugin())
  webpackConf.plugins.push(new webpack.optimize.UglifyJsPlugin())
}

// 加载配置
loadWebpackConfList()

module.exports = webpackConf

/**
 * 尝试加载每个模块的webpack配置
 */
function loadWebpackConfList () {
  const moduleList = findModuleList(pathDirname)

  // 增加：开发者项目目录下的config文件夹
  // 注意：Hook机制不保证向后兼容
  moduleList.push({ name: '', path: path.join(pathProject, 'config') })

  for (let i = 0, len = moduleList.length; i < len; i++) {
    const moduleItem = moduleList[i]
    const fileConf = path.join(moduleItem.path, 'webpack.config.js')
    if (fs.existsSync(fileConf)) {
      try {
        const moduleWebpackConf = require(fileConf)
        if (moduleWebpackConf.postHook) {
          moduleWebpackConf.postHook(webpackConf, {
            appPackageName,
            nodeConf,
            pathDist,
            pathDirname,
            zipReses,
            pathBuild
          }, options)
        }
      }
      catch (err) {
        console.error(`加载webpack配置文件[${fileConf}]出错：${err.message}`)
      }
    }
  }
}

/**
 * 查找模块列表
 * @param parentDir
 * @return {Array}
 */
function findModuleList (parentDir) {
  const moduleList = []
  const fileNameList = fs.readdirSync(pathDirname)
  for (let i = 0, len = fileNameList.length; i < len; i++) {
    const fileName = fileNameList[i]
    const filePath = path.join(parentDir, fileName)
    const fileStat = fs.statSync(filePath)
    if (fileStat.isDirectory()) {
      moduleList.push({
        name: fileName,
        path: filePath
      })
    }
  }
  return moduleList
}

/**
 * 解析NODE环境的参数
 */
function parseEnv(){
  const config = {
    // 平台：na
    NODE_PLATFORM: process.env.NODE_PLATFORM,
    // 阶段: dv|qa|ol
    NODE_PHASE: process.env.NODE_PHASE,
    // 是否注入测试框架
    NODE_TEST: process.env.NODE_TEST
  }
  colorconsole.info(`配置环境：${JSON.stringify(config)}`)
  return config
}

/**
 * 验证项目配置正确
 */
function validateProject () {
  if (!fs.existsSync(pathManifest)) {
    colorconsole.throw(`请确认项目%projectDir%/src/下存在manifest.json文件：${pathManifest}`)
  }

  if (!fs.existsSync(pathEntry)) {
    colorconsole.throw(`请确认项目%projectDir%/src/下存在game.js文件：${pathEntry}`)
  }

  // 清空build目录
  fsExtra.emptyDirSync(pathBuild)
  // 清空dist路径
  if (fs.existsSync(pathDist)) {
    const zipfiles = fs.readdirSync(pathDist)
    zipfiles.forEach(function (file) {
      const curPath = pathDist + '/' + file
      if (fs.statSync(curPath).isFile()) {
        fs.unlinkSync(curPath)
      }
    })
  }
  return true
}


/**
 * 获取项目名
 */
function getProjectName() {
  const config = JSON.parse(fs.readFileSync(pathManifest))
  return (config && config.package) || 'Bundle'
}

/**
 * 提取资源文件
 * @param dir
 * @param common
 */
function extractSourceFiles(dir, common) {
  dir = dir || '.'
  var directory = path.join(pathSrc, dir)
  var name
  // 递归遍历目录
  fs.readdirSync(directory)
    .forEach(function (file) {
      var fullpath = path.join(directory, file)
      var stat = fs.statSync(fullpath)
      var basename = path.basename(fullpath)
      var extname = path.extname(fullpath)
      if (stat.isFile() ) {
        if(basename === nameManifest || FILE_EXT_NORES.indexOf(extname) < 0 ) { // 资源文件
          // 采用绝对路径
          name = path.join(nameBuild, dir, path.basename(file))
          name = name.replace(/\\/g, '/')
          zipReses[name] = fullpath
        }
      }
      else if (stat.isDirectory()) {
        var subdir = path.join(dir, file)
        var iscommon = common || (file.toLowerCase() === 'common')
        extractSourceFiles(subdir, iscommon)
      }
    })
}
